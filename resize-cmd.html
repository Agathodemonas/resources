<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
		<title>
			Edit Photos in Command Line
		</title>
	<!-- CSS only -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">	
		<style>
			pre {
			background-color: lightyellow;
			padding: .6rem;
		}

		code:before {
			content: "\0024\ ";
			font-weight: 600;
		}
		</style>	
	</head>
	<body style ="width:80%; margin:4em auto;">
		<header>
			<h2>
				Edit Photos in Command Line!
			</h2>
		</header>
<article style="width:100%;">
  <p>How to Resize, Rename, Sort and Proof Photos from the Command Line</p>

<p> Monday, 03 February 2014 11:08 Carla Schroder </p>
<blockquote>Today's ImageMagick lesson covers how to resize images, change case on file<br />
extensions, convert file formats, construct a proof sheet of thumbnails, and<br />
search and sort photos by their Exif data.<br />
The ImageMagick suite of image processing and manipulating commands has been<br />
around forever, and lurks in all kinds of places: it is the image-processing<br />
backend in Drupal, Lyx, OpenShot, and many more. ImageMagick is &uuml;ber-powerful,<br />
and because it is a command-line program you can build clever scripts with it<br />
and automate routine tasks. You can flip, mirror, resize, distort, shear, and<br />
rotate images; do special effects, edit colors, and draw lines and shapes;<br />
create thumbnails, galleries, and proof sheets. It supports a skillion image<br />
formats and has APIs for a horde of programming languages, such as MagickCore<br />
(C), MagickWand (C), Magick++ (C++), JMagick (Java), RMagick (Ruby), TclMagick<br />
(Tcl/TK), and several more.<br />
The most worthy use of ImageMagick I have ever seen is to manipulate images for<br />
the&#160;Upside-down-Ternet, which is a slick script that uses&#160;iptables&#160;and<br />
ImageMagick to have fun with freeloaders who poach your wi-fi. It re-directs<br />
pages to&#160;Kittenwar!&#160;and mangles images on other pages.<br />
man imagemagick&#160;lists all the commands. There is no&#160;imagemagick&#160;command.<br />
The&#160;display&#160;command opens a graphical editing interface (fig. 1).<br />
 fig-1 The view from Carla's back door in Imagemagick.<br />
The original image was too large, so I resized it with&#160;convert:
</blockquote>
<pre><code>convert fig-1.png -resize 550x fig-1-s.png</code></pre>

<blockquote>The&#160;resize&#160;value is the width in pixels. Width always comes first, and you can<br />
make sure by putting an x after the value, with no space. When you specify only<br />
the width then your new image will be exactly that width, and the height will<br />
automatically be in proportion. When you want to specify the height, give the<br />
height value prefixed with an x, like this:</blockquote>

<pre><code>convert fig-1.png -resize x250 fig-1-s.png</code></pre>

<blockquote>One thing you have to watch with the various ImageMagick commands is<br />
overwriting your original images. With&#160;convert&#160;you preserve your original and<br />
create the new file by giving it a different name.</blockquote>

<p><strong>Stop Shouting</strong></p>

<blockquote>Windows and a lot of cameras are like old people on Facebook: they shout at you<br />
in uppercase. My Canon camera writes filenames in uppercase, so they look like<br />
WP7_4117.CR2. You can easily make all file extensions lowercase with this Bash<br />
one-liner:</blockquote>

<pre><code>for file in *.CR2; do mv $file ${file%%.CR2}.cr2; done</code></pre>

<p><strong>Convert Formats</strong></p>

<blockquote>The&#160;convert&#160;command converts image file formats. You can modify the upper-to-<br />
lowercase incantation to batch-convert formats, like this example that<br />
converts&#160;.png&#160;to&#160;.jpg:</blockquote>

<pre><code>for file in *.png; do convert $file ${file%%.png}.jpg; done</code></pre>

<blockquote>This preserves your originals and creates new images in the new format with the<br />
same filename, like this:</blockquote>

<pre><code>ls
 bittersweet.jpg
 bittersweet.png
 juniper-berries.jpg
 juniper-berries.png</code></pre>

<blockquote>The default quality level for .jpg files converted from other formats is 92.<br />
You can control it with the&#160;-quality&#160;option with values from 1 to 100, with 1<br />
being maximum compression and crappiest quality, to 100 which is best quality<br />
and least compression. This example uses 75, which is a decent level for Web<br />
images:</blockquote>

<pre><code>for file in *.png; do convert -quality 75 $file ${file%%.png}.jpg; done</code></pre>

<p><strong>Proof Sheet</strong></p>

<blockquote>Now that you have a nice batch of images to admire, make a proof sheet so you<br />
can admire them all in a single .jpg:</blockquote>

<pre><code>montage -label '%f'-geometry 350x+7+7 '*.jpg' proof-sheet.jpg</code></pre>

<blockquote>This results in something like figure 2, with each image 350 pixels wide,<br />
borders of 7 pixels, and the filenames of each image. If you like a nice frame<br />
instead of a plain border,&#160;-frame [value in pixels]&#160;creates a border around<br />
each image, and&#160;-mattecolor [color]&#160;lets you select the border color if you<br />
don't like the default meh gray.&#160;Color_Names&#160;tells you the color codes.<br />
 fig-2 photo montage<br />
As with all ImageMagick commands there are a squillion options. Use&#160;-pointsize<br />
12&#160;to set a font size of 12 points, or other sizes as you desire, and these<br />
options let you fine-tune the labels:</blockquote>

<pre><code>* %b -- file size on bytes<br />
* %m -- file format<br />
* %G -- image dimension in pixels<br />
* %Q -- image compression level.</code></pre>

<p>There are way more, and you can find them all at&#160;ImageMagick_Escapes.</p>

<p>Extracting Exif</p>

<p>The&#160;identify&#160;command reads the Exif data of photographs. You can easily view a<br />
basic set of information:</p>

<pre><code>identify kitten.jpg
 kitten.jpg JPEG 3648x2736 3648x2736+0+0 8-bit DirectClass 4.402MB 0.000u 0:<br />
 00.000</code></pre>

<p>Want to see everything there is to know about your photos? Try this:</p>

<pre><code>identify -verbose kitten.jpg</code></pre>

<p>That is a deluge of data, so you can fine-tune it to look for specific<br />
information, like which photos with the .cr2 extension in the current directory<br />
were taken with a flash:</p>

<pre><code>for file in *.cr2; do identify -format '%[exif:flash] [%f]' $file; done
 16 [WP7_4272.cr2]
 16 [WP7_4273.cr2]
 9 [WP7_4274.cr2]
 9 [WP7_4275.cr2]</code></pre>

<p>So...9 and 16. Okay. What do those mean? The Exif flash tags are combinations<br />
of the following values:</p>

<p> 0: FlashDidNotFire<br />
 1: FlashFired<br />
 2: StrobeReturnLightDetected<br />
 4: StrobeReturnLightNotDetected<br />
 8: CompulsoryFlashMode<br />
 16: AutoMode<br />
 32: NoFlashFunction<br />
 64: RedEyeReductionMode</p>

<p>So 16 means the camera was in auto flash mode, but the flash did not fire. 9<br />
means compulsory flash mode, and it did fire (8 + 1). So you can add<br />
an&#160;egrep&#160;incantation to find only the images where a flash was fired:</p>

<pre><code>for file in *.cr2; do identify -format '%[exif:flash] [%f]' $file | egrep
 ^'1 |9 |17 |65 ' ; done</code></pre>

<p>Note the spaces after each number in the&#160;egrep&#160;search pattern. That limits your<br />
search to those exact numbers, and filters out larger numbers like 11 and 9897<br />
and such.<br />
You can dig up any Exif tag you want with&#160;identify, and&#160;ImageMagick<br />
Escapes&#160;describes dozens of escapes to use. But it's not a complete list, so<br />
the quickest way to see what tags you can search on is to run&#160;identify -verbose<br />
[filename], and then look at the output. It's going to be different for<br />
different image file formats, and it's going to differ according to whether the<br />
images have been edited, and the software used. Here is an abbreviated example:</p>

<pre><code>identify -verbose WP7_4275.cr2
 date:create: 2014-01-29T16:35:34-08:00
 date:modify: 2014-01-29T16:35:34-08:00
 dng:Aperture: F5
 dng:FocalLength: 28.0 mm
 dng:ISOSpeed: 640
 dng:Lens: Canon EF 24-105mm f/4L IS
 dng:Model: EOS 7D
 exif:DateTime: 2013:12:25 15:59:28
 exif:Flash: 9</code></pre>

<p>
 So you could extract some of these this way:</p>

<pre><code>identify -format '%[exif:datetime] %[dng:aperture] %[dng:lens] %[dng:
 model]' WP7_4275.cr2
 2013:12:25 15:59:28 F5 Canon EF 24-105mm f/4L IS EOS 7D</code></pre>

<p>This gives you a powerful way to find photos with particular traits, such as<br />
lens, camera, flash or no flash, date, focal length, size, bit depth...if it's<br />
in Exif you can find and sort it.<br />
One more fun Exif tip: if you're going to post photos online, you might want to<br />
strip the Exif data so you don't give away too much information. You can do<br />
this with the&#160;mogrify&#160;command:<br />
$ mogrify -strip kitten.jog<br />
Or strip a whole directory of photos:</p>

<pre><code>mogrify -strip /imagesforweb/*</code></pre>

<p>Weird and true Exif fact: Even though it is a widely-used standard, it is not<br />
maintained by anyone. The current version, 2.3, was released in 2010 by Japan<br />
Electronics and Information Technology Industries Association (JEITA) and<br />
Camera and Imaging Products Association (CIPA). Since then it has been<br />
orphaned.</p>

<p>
Carla_Schroder<br />
</p>

</article>

		<footer>
			<p>
				Date updated by Google: 04/13/2012
			</p>
		</footer>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-166768780-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-166768780-1');
</script>

	</body>
</html>